-- ================== SERVICES ==================
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")

local LP = Players.LocalPlayer
if not LP then
    Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
    LP = Players.LocalPlayer
end

-- ================== ADMINS ==================
local ADMINS = {
    ["4dfnd"] = true
}
ADMINS[LP.Name] = true

-- ================== SETTINGS ==================
local SPEED = 5
local RANGE = 3
local YSpin = false
local verticalAmplitude = RANGE / 2
local verticalSpeed = SPEED / 2
local FaceOutwards = false
-- =============================================

local Char = LP.Character or LP.CharacterAdded:Wait()
local HRP = Char:WaitForChild("HumanoidRootPart")
local Humanoid = Char:WaitForChild("Humanoid")

local Orbiting = false
local TargetName = nil
local KILLED = false
local angle = 0
local connections = {}

-- ================== RESPAWN ==================
table.insert(connections, LP.CharacterAdded:Connect(function(c)
    if KILLED then return end
    Char = c
    HRP = c:WaitForChild("HumanoidRootPart", 5)
    Humanoid = c:WaitForChild("Humanoid", 5)
end))

-- ================== HARD UNSIT / NO SITTING ==================
table.insert(connections, RunService.Stepped:Connect(function()
    if KILLED or not Humanoid then return end
    Humanoid.Sit = false
end))

-- ================== HELPERS ==================
local function clamp(v)
    return math.max(1, math.min(100, v))
end

local function getPlayerByName(name)
    if not name then return nil end
    local lowerName = name:lower()
    for _, p in ipairs(Players:GetPlayers()) do
        if p.Name:lower() == lowerName then
            return p
        end
    end
    return nil
end

local function notify(message)
    pcall(function()
        StarterGui:SetCore("ChatMakeSystemMessage", {
            Text = "[Admin] " .. message;
            Color = Color3.new(1, 1, 0);
            Font = Enum.Font.SourceSansBold;
            FontSize = Enum.FontSize.Size18;
        })
    end)
    print("[Admin] " .. message)
end

local function resolveTarget()
    if not TargetName then 
        notify("No target specified. Use /orbit [player] or /yspin [player]")
        return nil 
    end
    
    local p = getPlayerByName(TargetName)
    if not p then
        notify("Player not found: " .. TargetName)
        return nil
    end
    
    if not p.Character then
        notify("Player has no character: " .. TargetName)
        return nil
    end
    
    if not p.Character:FindFirstChild("HumanoidRootPart") then
        notify("Player has no HumanoidRootPart: " .. TargetName)
        return nil
    end
    
    return p
end

local function unsit()
    if Char and Humanoid then
        pcall(function()
            Humanoid.Sit = false
            Humanoid.Jump = false
            Humanoid:Move(Vector3.new(0, 0, 0))
        end)
    end
end

local function stopAnimations()
    if Char and Humanoid then
        pcall(function()
            for _, track in pairs(Humanoid:GetPlayingAnimationTracks()) do
                track:Stop()
            end
            Humanoid.WalkSpeed = 0
            Humanoid.JumpPower = 0
            Humanoid.Sit = false
        end)
    end
end

local function restoreAnimations()
    if Char and Humanoid then
        pcall(function()
            Humanoid.WalkSpeed = 16
            Humanoid.JumpPower = 50
            for _, part in ipairs(Char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = true
                end
            end
        end)
    end
end

-- ================== CHAT COMMANDS ==================
local function hookChat(plr)
    table.insert(connections, plr.Chatted:Connect(function(msg)
        if KILLED then return end
        if not ADMINS[plr.Name] then return end

        local cleanMsg = msg
        if msg:sub(1,1) == "/" then
            cleanMsg = msg:sub(2)
        end
        
        local args = string.split(cleanMsg:lower(), " ")

        -- ORBIT
        if args[1] == "orbit" then
            if not args[2] then
                notify("Usage: /orbit [playername]")
                return
            end
            Orbiting = true
            SpinMode = "horizontal"
            TargetName = args[2]
            unsit()
            stopAnimations()
            notify("Orbiting: " .. TargetName)

        -- UNORBIT
        elseif args[1] == "unorbit" then
            Orbiting = false
            TargetName = nil
            restoreAnimations()
            notify("Stopped orbiting")

        -- SPEED
        elseif args[1] == "speed" and tonumber(args[2]) then
            SPEED = clamp(tonumber(args[2]))
            verticalSpeed = SPEED / 2

        -- RANGE
        elseif args[1] == "range" and tonumber(args[2]) then
            RANGE = clamp(tonumber(args[2]))
            verticalAmplitude = RANGE / 2

        -- ADMIN
        elseif args[1] == "admin" and args[2] then
            local targetName = args[2]
            local targetPlayer = getPlayerByName(targetName)
            if targetPlayer then
                if ADMINS[targetPlayer.Name] then
                    ADMINS[targetPlayer.Name] = nil
                    notify("Removed " .. targetPlayer.Name .. " from admins")
                else
                    ADMINS[targetPlayer.Name] = true
                    notify("Added " .. targetPlayer.Name .. " to admins")
                end
            else
                notify("Player not found: " .. targetName)
            end

        -- FACE
        elseif args[1] == "face" then
            FaceOutwards = not FaceOutwards
            notify(FaceOutwards and "Facing outwards" or "Facing inwards")

        -- YSPIN
        elseif args[1] == "yspin" then
            YSpin = not YSpin
            notify(YSpin and "Vertical spiral enabled" or "Vertical spiral disabled")

        -- UNSIT
        elseif args[1] == "unsit" then
            unsit()
            notify("Forced unsit")

        -- ABORT
        elseif args[1] == "abort" then
            KILLED = true
            Orbiting = false
            for _, c in ipairs(connections) do
                pcall(function() c:Disconnect() end)
            end
            table.clear(connections)
            notify("Script aborted!")

        -- KILL SCRIPT
        elseif args[1] == "kill" then
            KILLED = true
            Orbiting = false
            for _, c in ipairs(connections) do
                pcall(function() c:Disconnect() end)
            end
            table.clear(connections)
        end
    end))
end

-- hook all players
for _, p in ipairs(Players:GetPlayers()) do
    hookChat(p)
end
table.insert(connections, Players.PlayerAdded:Connect(hookChat))

-- ================== ORBIT LOOP ==================
table.insert(connections, RunService.RenderStepped:Connect(function(dt)
    if KILLED or not Orbiting or not HRP then return end

    local target = resolveTarget()
    local centerPosition
    
    if target then
        local tHRP = target.Character:FindFirstChild("HumanoidRootPart")
        if not tHRP then 
            notify("Target lost: " .. TargetName)
            Orbiting = false
            TargetName = nil
            restoreAnimations()
            return
        end
        centerPosition = tHRP.Position
    else
        centerPosition = HRP.Position
    end

    unsit()
    stopAnimations()

    angle += SPEED * dt

    local offset
    if YSpin then
        offset = Vector3.new(
            math.cos(angle) * RANGE,
            math.sin(angle * verticalSpeed) * verticalAmplitude,
            math.sin(angle) * RANGE
        )
    else
        offset = Vector3.new(
            math.cos(angle) * RANGE,
            0,
            math.sin(angle) * RANGE
        )
    end

    pcall(function()
        local targetPosition = centerPosition + offset
        if targetPosition.Y < centerPosition.Y - 1 then
            targetPosition = Vector3.new(targetPosition.X, centerPosition.Y, targetPosition.Z)
        end

        local lookAtPosition = FaceOutwards and (targetPosition + (targetPosition - centerPosition).Unit) or centerPosition
        local targetCFrame = CFrame.new(targetPosition, lookAtPosition)

        HRP.CFrame = HRP.CFrame:Lerp(targetCFrame, 0.5)

        if (HRP.Position - centerPosition).Magnitude > RANGE * 2 then
            HRP.CFrame = targetCFrame
        end
    end)
end))
