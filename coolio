-- ================== SERVICES ==================
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")

local LP = Players.LocalPlayer
if not LP then
	Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
	LP = Players.LocalPlayer
end

-- ================== ADMINS ==================
local ADMINS = {
	["4dfnd"] = true
}
ADMINS[LP.Name] = true

-- ================== SETTINGS ==================
local SPEED = 5
local RANGE = 3
-- =============================================

local Char = LP.Character or LP.CharacterAdded:Wait()
local HRP = Char:WaitForChild("HumanoidRootPart")
local Humanoid = Char:WaitForChild("Humanoid")

local Orbiting = false
local TargetName = nil
local KILLED = false
local SpinMode = "horizontal" -- "horizontal" or "vertical"

local angle = 0
local connections = {}

-- ================== RESPAWN ==================
table.insert(connections, LP.CharacterAdded:Connect(function(c)
	if KILLED then return end
	Char = c
	HRP = c:WaitForChild("HumanoidRootPart", 5)
	Humanoid = c:WaitForChild("Humanoid", 5)
end))

-- ================== HARD UNSIT / NO SITTING ==================
table.insert(connections, RunService.Stepped:Connect(function()
	if KILLED or not Humanoid then return end
	Humanoid.Sit = false
end))

-- ================== HELPERS ==================
local function clamp(v)
	return math.max(1, math.min(100, v))
end

local function getPlayerByName(name)
	if not name then return nil end
	local lowerName = name:lower()
	for _, p in ipairs(Players:GetPlayers()) do
		if p.Name:lower() == lowerName then
			return p
		end
	end
	return nil
end

local function notify(message)
	pcall(function()
		StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[Admin] " .. message;
			Color = Color3.new(1, 1, 0);
			Font = Enum.Font.SourceSansBold;
			FontSize = Enum.FontSize.Size18;
		})
	end)
	print("[Admin] " .. message)
end

local function resolveTarget()
	if not TargetName then 
		notify("No target specified. Use /orbit [player] or /yspin [player]")
		return nil 
	end
	
	local p = getPlayerByName(TargetName)
	if not p then
		notify("Player not found: " .. TargetName)
		return nil
	end
	
	if not p.Character then
		notify("Player has no character: " .. TargetName)
		return nil
	end
	
	if not p.Character:FindFirstChild("HumanoidRootPart") then
		notify("Player has no HumanoidRootPart: " .. TargetName)
		return nil
	end
	
	return p
end

local function unsit()
	if Char and Humanoid then
		pcall(function()
			Humanoid.Sit = false
			Humanoid.Jump = false
			Humanoid:Move(Vector3.new(0, 0, 0))
		end)
	end
end

local function stopAnimations()
	if Char and Humanoid then
		pcall(function()
			-- Stop all animations
			for _, track in pairs(Humanoid:GetPlayingAnimationTracks()) do
				track:Stop()
			end
			
			-- Disable platform stand to prevent animations
			Humanoid.PlatformStand = true
			
			-- Set walk speed to 0 to prevent movement
			Humanoid.WalkSpeed = 0
			Humanoid.JumpPower = 0
			
			-- No sit
			Humanoid.Sit = false
			
			-- No clip - make character cancollide false
			for _, part in ipairs(Char:GetDescendants()) do
				if part:IsA("BasePart") then
					part.CanCollide = false
				end
			end
		end)
	end
end

local function restoreAnimations()
	if Char and Humanoid then
		pcall(function()
			-- Restore platform stand
			Humanoid.PlatformStand = false
			
			-- Restore movement
			Humanoid.WalkSpeed = 16
			Humanoid.JumpPower = 50
			
			-- Restore collision
			for _, part in ipairs(Char:GetDescendants()) do
				if part:IsA("BasePart") then
					part.CanCollide = true
				end
			end
		end)
	end
end

-- ================== CHAT COMMANDS ==================
local function hookChat(plr)
	table.insert(connections, plr.Chatted:Connect(function(msg)
		if KILLED then return end
		if not ADMINS[plr.Name] then return end

		-- Remove prefix and split
		local cleanMsg = msg
		if msg:sub(1,1) == "/" then
			cleanMsg = msg:sub(2)
		end
		
		local args = string.split(cleanMsg:lower(), " ")

		-- ORBIT
		if args[1] == "orbit" then
			if not args[2] then
				notify("Usage: /orbit [playername]")
				return
			end
			
			Orbiting = true
			SpinMode = "horizontal"
			TargetName = args[2]
			unsit()
			stopAnimations()
			
			notify("Orbiting: " .. TargetName)

			-- UNORBIT
		elseif args[1] == "unorbit" then
			Orbiting = false
			TargetName = nil
			restoreAnimations()
			
			notify("Stopped orbiting")

			-- SPEED
		elseif args[1] == "speed" and tonumber(args[2]) then
			SPEED = clamp(tonumber(args[2]))

			-- RANGE
		elseif args[1] == "range" and tonumber(args[2]) then
			RANGE = clamp(tonumber(args[2]))

			-- ADMIN
		elseif args[1] == "admin" and args[2] then
			local targetName = args[2]
			local targetPlayer = getPlayerByName(targetName)
			
			if targetPlayer then
				if ADMINS[targetPlayer.Name] then
					ADMINS[targetPlayer.Name] = nil
					notify("Removed " .. targetPlayer.Name .. " from admins")
				else
					ADMINS[targetPlayer.Name] = true
					notify("Added " .. targetPlayer.Name .. " to admins")
				end
			else
				notify("Player not found: " .. targetName)
			end
			
			-- YSPIN
		elseif args[1] == "yspin" then
			if not args[2] then
				notify("Usage: /yspin [playername]")
				return
			end
			
			Orbiting = true
			SpinMode = "vertical"
			TargetName = args[2]
			unsit()
			stopAnimations()
			
			notify("Y-Spinning: " .. TargetName)
			
			-- KILL SCRIPT
		elseif args[1] == "kill" then
			KILLED = true
			Orbiting = false

			for _, c in ipairs(connections) do
				pcall(function() c:Disconnect() end)
			end
			table.clear(connections)
		end
	end))
end

-- hook players
for _, p in ipairs(Players:GetPlayers()) do
	hookChat(p)
end
table.insert(connections, Players.PlayerAdded:Connect(hookChat))

-- ================== ORBIT LOOP ==================
table.insert(connections, RunService.RenderStepped:Connect(function(dt)
	if KILLED or not Orbiting or not HRP then return end

	local target = resolveTarget()
	if not target then 
		-- Stop orbiting if target is invalid
		Orbiting = false
		TargetName = nil
		restoreAnimations()
		return 
	end

	local tHRP = target.Character:FindFirstChild("HumanoidRootPart")
	if not tHRP then 
		notify("Target lost: " .. TargetName)
		Orbiting = false
		TargetName = nil
		restoreAnimations()
		return
	end

	unsit()
	stopAnimations()

	angle += SPEED * dt

	local offset
	if SpinMode == "vertical" then
		-- Vertical spinning (up and down around target - Y-axis)
		offset = Vector3.new(
			math.cos(angle) * RANGE,
			math.sin(angle) * RANGE,
			0
		)
	else
		-- Horizontal spinning (original orbit)
		offset = Vector3.new(
			math.cos(angle) * RANGE,
			0,
			math.sin(angle) * RANGE
		)
	end

	pcall(function()
		-- Smooth CFrame interpolation to reduce jittering
		local targetCFrame = CFrame.new(
			tHRP.Position + offset,
			tHRP.Position
		)
		
		-- Smooth transition using lerp
		HRP.CFrame = HRP.CFrame:Lerp(targetCFrame, 0.3)
	end)
end))
